## PROJECT K23A Εργασία 1
	Χίου Ρίτα Άννα sdi1700192
	Χουσιανίτη Κατερίνα sdi1700194
	Μπούρα Τατιάνα sdi1700100

## Λειτουργικότητα / Σχεδιαστικές επιλογές

**Generic List**
Χρησιμοποιήσαμε μια generic λίστα καθώς παρατηρήσαμε πως ήταν απαραίτητη σε παραπάνω από μία υλοποιήσεις, όπως την αποθήκευση των ζευγών <όνομα_ιδιότητας,generic_list(τιμή_ιδιότητας)> (τα οποία ονομάζουμε tuples), τη δημιουργία κλικών από spec_ids και την διαχείριση του collision στα hashtable.
H append είναι ουσιαστικά put_at_front εφόσον δεν μας ενδιαφέρει η σειρά, αφού τότε έχει πολυπλοκότητα Ο(1).

**Hash Table**
Αποφασίσαμε ότι η πολυπλοκότητα για την πρόσβαση στο εκάστοτε spec_id είναι ιδιαίτερα σημαντική λόγω του πλήθους ζευγών που ελέγχονται κατά την ανάγνωση των dataset W,Y. Επομένως επιλέξαμε να αποθηκεύσουμε τα specs (spec_id,tuples,cliques) σε ένα hash table που κάθε στοιχείο του table δείχνει σε μία λίστα από buckets, τα οποία buckets αποθηκεύουν εγγραφές. Έτσι, κάθε εγγραφή σε κάθε bucket αποτελείται από το spec_id, μια λίστα με ζεύγη <propertyName, λίστα από τιμές propertyValueList (περισσότερα του ενός στοιχεία σε περίπτωση πίνακα)> και μία λίστα από spec_ids που δηλώνει την κλίκα των spec που ταιριάζουν. 
Το μέγεθος του hash καθορίζεται από το συνολικό πλήθος των καμερών, καθώς στην αρχή του προγράμματος μετράμε τους φακέλους και το πόσες κάμερες έχουν μέσα, διατηρώντας τον συνολικό αριθμό.

**Διάβασμα από dataset X**
παραδοχές για πίνακες κτλπ

**Διαχείση ταιριασμάτων**
Όταν διαβάσουμε από το dataset W ένα ζεύγος left_spec_id, right_spec_id τα όποια είναι ίδια (έχουν δηλαδή label να ισούται με 1), hash-άρουμε το κάθε προαναφερθέν id, βρίσκουμε σε ποιά θέση του hash table βρίσκεται και ύστερα με τη συνάρτηση foundInHT επιστρέφουμε το bucket στο οποίο ανήκει το συγκεκριμένο id καθώς και τη θέση που καταλαμβάνει στο bucket(δηλαδή ποιά εγγραφή είναι). Αφότου έχουμε τις ακριβείς θέσεις και των 2 spec id, καλούμε τη συνάρτηση changePointers η οποία αφότου ελέγξει ότι δεν αναφερόμαστε στην ίδια κλίκα(δηλαδή αποφεύγει φαινόμενα κυκλισμού), κάνει merge τις δύο κλίκες (λίστες) και σε κάθε στοιχείο της merged πια κλίκας πηγαίνει και αλλάζει τον pointer του προκειμένου όλα τα στοιχεία της κλίκας να δείχνουν(άρα και να αναφέρονται) στην ίδια κλίκα. 

**Memory reusability**
Γενικά, το πρόγραμμα όπου είναι εφικτό δεν κάνει alloc αλλά χρησιμοποιεί ήδη δεσμευμένη μνήμη προκειμένου να μην γίνονται σπατάλες. Για παράδειγμα, τα spec_ids στην κλίκα είναι αποθηκευμένα στις ίδιες θέσεις μνήμης με το spec_id(εν ονόματι path) στην εγγραφή του bucket. Ομοίως, οι ίδιες κλίκες είναι αποθηκευμένες στην ίδια θέση μνήμης.

**Εκτύπωση αποτελέσματος**
Προκειμένου να δημιουργηθεί το αρχείο εξόδου output.txt, καλείται η συνάρτηση makeOutputFile της hash η οποία για κάθε εγγραφή των bucket στο hash table επισκέπτεται την κλίκα (εφόσον δεν την έχει ξαναεπισκεφτεί) και μέσω της συνάρτησης makeOutputFileList εκτυπώνει τις κλίκες με την εξής λογική προκειμένου να αποφύγει τα διπλότυπα: Έστω μια κλίκα με τα στοιχεία a b c. Στην αρχή, εκτυπώνει το a σε ζεύγος με τα δεξιά του, δηλαδή ab ac. Έπειτα, κάνει το ίδιο με το b. Το c δεν έχει δεξί, συνεπώς η εκτύπωση της κλίκας τερματίζει. Δεν εκτυπώνει τα αριστερά, διότι έτσι θα είχαμε διπλότυπα. 

**Unit Testing**
Εφαρμόζουμε unit testing σε όλες τις δομές που έχουμε χρησιμοποιήσει (generic list, hashTable, tuple structure) λαμβάνοντας υπόψιν τις πολλαπλές μορφές της λίστας στο πρόγραμμά μας. Οι μόνες συναρτήσεις που δεν ελέγχονται από το testing είναι αυτές που ασχολούνται με το input-output του προγράμματος, αυτές που αποδεσμεύουν μνήμη(αν και το πρόγραμμα δεν έχει κανένα leak ή error σύμφωνα με το Valgrind) και κάποιες μικρές συναρτήσεις εντός των δομών που ελέγχονται έμμεσα, αφού αποτελούν τμήμα μεγαλύτερων συναρτήσεων που ελέγχονται κανονικά, βλέπε η getBucket η οποία ελέγχεται έμεσα από τον έλεγχο της foundInHT. 
